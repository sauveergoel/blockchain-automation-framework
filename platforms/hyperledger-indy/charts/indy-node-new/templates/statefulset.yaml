apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: "{{ $.Values.metadata.name }}"
  namespace: "{{ $.Values.metadata.namespace }}"
spec:
  serviceName: "{{ $.Values.metadata.name }}"
  replicas: 1
  selector:
    matchLabels:
      app: "{{ $.Values.metadata.name }}"
  template:
    metadata:
      labels:
        app: "{{ $.Values.metadata.name }}"
    spec:
      securityContext:
        fsGroup: 1000
      serviceAccountName: {{ $.Values.vault.serviceAccountName }}
      initContainers:
      - name:  "{{ $.Values.image.initContainer.name }}"
        image:  "{{ $.Values.image.initContainer.repository }}"
        imagePullPolicy: Always
        env:
         - name: VAULT_ADDR
           value: {{ $.Values.vault.address }}
         - name: VAULT_AUTH_PATH
           value: {{ $.Values.vault.authPath }}
         - name: VAULT_ROLE
           value: {{ $.Values.vault.role }}
         - name: KEY_PATH
           value: {{ $.Values.vault.keyPath }}
         - name: NODE_ID
           value: {{ $.Values.vault.nodeId }}
         - name: ORGANIZATION_NAME
           value: "{{ $.Values.organization.name }}"
         - name: DOMAIN_GENESIS
           value: "{{ $.Values.genesis.domain }}"
        command:
        - "sh"
        - "-c"
        - >
          apk update;
          apk add curl jq;

          validateVaultResponse () {
          if echo ${2} | grep "errors"; then
           echo "ERROR: unable to retrieve ${1}: ${2}"
           exit 1
           fi
          }

          KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token);

          response=$(curl -s -o /dev/null -w "%{http_code}" $VAULT_ADDR/v1/sys/health);
          if [ $response != 200 ]; then
            exit 1
          fi

          curl --request POST --data '{"jwt": "'"$KUBE_TOKEN"'", "role": "'"$VAULT_ROLE"'"}' $VAULT_ADDR/v1/auth/$VAULT_AUTH_PATH/login | jq -j '.auth.client_token' > token;
          X_VAULT_TOKEN=$(cat token);

          mkdir -p ${KEY_PATH}/bls_keys ${KEY_PATH}/private_keys ${KEY_PATH}/public_keys ${KEY_PATH}/sig_keys ${KEY_PATH}/verif_keys ${KEY_PATH}C/private_keys ${KEY_PATH}C/public_keys ${KEY_PATH}C/sig_keys ${KEY_PATH}C/verif_keys ${KEY_PATH}/identity ${KEY_PATH}/identity/private ${KEY_PATH}/identity/public ${KEY_PATH}/admin ${KEY_PATH}/admin/private ${KEY_PATH}/admin/public ${KEY_PATH}/genesis;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/bls_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/public/bls_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.bls_pk" > ${KEY_PATH}/bls_keys/bls_pk;
          chmod 644 ${KEY_PATH}/bls_keys/bls_pk;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/bls_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/public/bls_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"bls-key-pop\"" > ${KEY_PATH}/bls_keys/bls-key-pop;
          chmod 644 ${KEY_PATH}/bls_keys/bls-key-pop;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/private/bls_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/private/bls_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.bls_sk" > ${KEY_PATH}/bls_keys/bls_sk;
          chmod 640 ${KEY_PATH}/bls_keys/bls_sk;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/private/private_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/private/private_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}.key_secret\"" > ${KEY_PATH}/private_keys/${NODE_ID}.key_secret;
          chmod 640 ${KEY_PATH}/private_keys/${NODE_ID}.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/public_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/public/public_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}.key\"" > ${KEY_PATH}/public_keys/${NODE_ID}.key.bootstrap;
          chmod 644 ${KEY_PATH}/public_keys/${NODE_ID}.key.bootstrap;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/private/sig_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/private/sig_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}.key_secret\"" > ${KEY_PATH}/sig_keys/${NODE_ID}.key_secret;
          chmod 640 ${KEY_PATH}/sig_keys/${NODE_ID}.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/verif_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/public/verif_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}.key\"" > ${KEY_PATH}/verif_keys/${NODE_ID}.key.bootstrap;
          chmod 644 ${KEY_PATH}/verif_keys/${NODE_ID}.key.bootstrap;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/verif_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/node/public/verif_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"verification-key\"" > ${KEY_PATH}/verif_keys/verification-key;
          chmod 644 ${KEY_PATH}/verif_keys/verification-key;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/client/private/private_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/client/private/private_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}C.key_secret\"" > ${KEY_PATH}C/private_keys/${NODE_ID}C.key_secret;
          chmod 640 ${KEY_PATH}C/private_keys/${NODE_ID}C.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/client/public/public_keys  | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/client/public/public_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}C.key\"" > ${KEY_PATH}C/public_keys/${NODE_ID}C.key;
          chmod 644 ${KEY_PATH}C/public_keys/${NODE_ID}C.key;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/client/private/sig_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/client/private/sig_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" |jq -j ".data.\"${NODE_ID}C.key_secret\"" > ${KEY_PATH}C/sig_keys/${NODE_ID}C.key_secret;
          chmod 640 ${KEY_PATH}C/sig_keys/${NODE_ID}C.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/client/public/verif_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/client/public/verif_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.\"${NODE_ID}C.key\"" > ${KEY_PATH}C/verif_keys/${NODE_ID}C.key;
          chmod 644 ${KEY_PATH}C/verif_keys/${NODE_ID}C.key;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/identity/private | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/identity/private)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.seed" > ${KEY_PATH}/identity/private/seed;
          chmod 644 ${KEY_PATH}/identity/private/seed;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/identity/public | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/identity/public)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.did" > ${KEY_PATH}/identity/public/did;
          chmod 644 ${KEY_PATH}/identity/public/did;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/admin/private | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/admin/private)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.seed" > ${KEY_PATH}/admin/private/seed;
          chmod 644 ${KEY_PATH}/admin/private/seed;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/admin/public | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (${NODE_ID}/admin/public)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j ".data.did" > ${KEY_PATH}/admin/public/did;
          chmod 644 ${KEY_PATH}/admin/public/did;          
        volumeMounts:
        - name: ebs-indy-node-keys
          mountPath: /keys
      containers:
        - name: "{{ $.Values.image.indyNode.name }}"
          image: "{{ $.Values.image.indyNode.repository }}"
          imagePullPolicy: Always
          ports:
            - containerPort: {{ $.Values.node.port }}
            - containerPort: {{ $.Values.client.port }}
          command: ["sh", "-c"]
          env:
            - name: INDY_NODE_NAME
              value: "{{ $.Values.node.name }}"
            - name: INDY_NODE_IP
              value: "{{ $.Values.node.ip }}"
            - name: INDY_NODE_PORT
              value: "{{ $.Values.node.port }}"
            - name: INDY_CLIENT_IP
              value: "{{ $.Values.client.ip }}"
            - name: INDY_CLIENT_PORT
              value: "{{ $.Values.client.port }}"
            - name: INDY_NETWORK_NAME
              value: "{{ $.Values.network.name }}"
            - name: POOL_GENESIS
              value: "{{ $.Values.genesis.pool }}"
            - name: DOMAIN_GENESIS
              value: "{{ $.Values.genesis.domain }}"
          args:
          - |-
            # tail -f /dev/null;

            apt-get update;
            apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys CE7709D068DB5E88;
            apt-get -y install software-properties-common;
            add-apt-repository "deb https://repo.sovrin.org/sdk/deb xenial stable";
            apt-get update;
            apt-get -y install indy-cli;              

            mkdir -p /var/lib/indy/genesis/${INDY_NETWORK_NAME};

            KEY_PATH=/var/lib/indy/keys/${INDY_NETWORK_NAME}/keys/${INDY_NODE_NAME}

            echo ${POOL_GENESIS} | base64 -d | sed -e 's/[ \t]*//' > /var/lib/indy/genesis/${INDY_NETWORK_NAME}/pool_transactions_genesis;
            echo ${DOMAIN_GENESIS} | base64 -d | sed -e 's/[ \t]*//' > /var/lib/indy/genesis/${INDY_NETWORK_NAME}/domain_transactions_genesis;
            
            init_indy_node ${INDY_NODE_NAME} ${INDY_NODE_IP} ${INDY_NODE_PORT} ${INDY_CLIENT_IP} ${INDY_CLIENT_PORT} $(cat ${KEY_PATH}/identity/private/seed) > init_output.txt;

            cat init_output.txt
            echo "indy node initialised";

            bls_pk=$(cat init_output.txt | grep "BLS Public key is" | grep -P '[A-z0-9]+$' -o);
            verify_key=$(cat init_output.txt | grep "Verification key is" | grep -P '[A-z0-9]+$' -o);
            bls_pk_pop=$(cat init_output.txt | grep "Proof of possession for BLS key is" | grep -P '[A-z0-9]+$' -o);

            echo "{
            \"version\": 1,
            \"dids\": [{
            \"did\": \"$(cat ${KEY_PATH}/admin/public/did)\", 
            \"seed\": \"$(cat ${KEY_PATH}/admin/private/seed)\"
            }]
            }" > admindid.txt;

            cat admindid.txt;

            echo "{
            \"version\": 1,
            \"dids\": [{
            \"did\": \"$(cat ${KEY_PATH}/identity/public/did)\", 
            \"seed\": \"$(cat ${KEY_PATH}/identity/private/seed)\"
            }]
            }" > did.txt;

            cat did.txt;

            echo "wallet create mywallet key=pass12345
            wallet open mywallet key=pass12345
            wallet list
            did import ./did.txt
            did import ./admindid.txt
            did list
            did use $(cat ${KEY_PATH}/admin/public/did)
            pool create mysandbox gen_txn_file=/var/lib/indy/genesis/${INDY_NETWORK_NAME}/pool_transactions_genesis
            pool connect mysandbox
            pool list
            exit" > init_node_txn;

            cat init_node_txn;

            indy-cli init_node_txn > init_node_txn.log;

            cat init_node_txn.log;

            echo "wallet open mywallet key=pass12345
            pool connect mysandbox
            did use $(cat ${KEY_PATH}/admin/public/did)
            ledger nym did=$(cat ${KEY_PATH}/identity/public/did) role=STEWARD verkey=$(cat init_node_txn.log | grep $(cat ${KEY_PATH}/identity/public/did) | grep -P '~[A-z0-9]*' -o | head -n 1)
            did use $(cat ${KEY_PATH}/identity/public/did)
            ledger node target=${verify_key} client_port=${INDY_CLIENT_PORT} client_ip=${INDY_CLIENT_IP} alias=${INDY_NODE_NAME} node_ip=${INDY_NODE_IP} node_port=${INDY_NODE_PORT} services=VALIDATOR blskey=${bls_pk} blskey_pop=${bls_pk_pop}
            exit" > node_txn

            cat node_txn;

            indy-cli node_txn > node_txn.log;

            cat node_txn.log;

            chmod +x /var/lib/indy/start-indy-node.sh;
            /var/lib/indy/start-indy-node.sh;
          volumeMounts:
            - name: ebs-indy-node-data
              mountPath: /var/lib/indy/data
            - name: ebs-indy-node-keys
              mountPath: /var/lib/indy/keys
            - name: {{ $.Values.metadata.name }}-config
              mountPath: /etc/indy/indy_config.py
              subPath: indy_config.py
      imagePullSecrets:
        - name: "{{ $.Values.image.pullSecret }}"
      volumes:
        - name: {{ $.Values.metadata.name }}-config
          configMap:
            name: {{ $.Values.metadata.name }}-config
  volumeClaimTemplates:
    - metadata:
        name: ebs-indy-node-data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: "{{ $.Values.storage.data.storageClassName }}"
        resources:
          requests:
            storage: "{{ $.Values.storage.data.storagesize }}"
    - metadata:
        name: ebs-indy-node-keys
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: "{{ $.Values.storage.data.storageClassName }}"
        resources:
          requests:
            storage: "{{ $.Values.storage.keys.storagesize }}"
